(defun list-of (&rest gens)
  `(lambda ()
     (mapcar 'funcall ',gens)))

(defun gen-bool ()
  "Generate t or nil"
  (lambda () (equal (random 2) 0)))

(defun gen-num ()
  "Generate positive random numbers"
  (lambda () (random ml4pg-test-complexity)))

(defun gen-char (&optional source)
  "Generate a random ASCII character. If an optional SOURCE string is given, its
   characters are used."
  (if source (gen-elem (split-string source "" t))
             (lambda () (format "%c" (random 255)))))

(defun gen-string (&optional op-len)
  "Generate a random ASCII string, of given (or random) length"
  (let ((len (cond ((functionp op-len)  op-len)
                   ((null      op-len) (gen-num))
                   (t                  (gen-const op-len)))))
    `(lambda ()
       (let ((str ""))
         (dotimes (i (funcall ,len) str)
           (setq str (concat str (funcall (gen-char)))))))))

(defun gen-nonempty-string ()
  "Generate a random ASCII string of at least one char"
  (gen-string (1+ (funcall (gen-num)))))

(defun gen-list (elem-gen &optional op-len)
  "Generate a random list, using the given element-generating function, of the
   given (or random) length"
  (let ((len (cond ((functionp op-len)  op-len)
                   ((null      op-len) (gen-num))
                   (t                  (gen-const op-len)))))
    `(lambda ()
       (let (lst)
         (dotimes (i (funcall ,len) lst)
           (setq lst (cons (funcall ,elem-gen) lst)))))))

(defun gen-nonempty-list (elem-gen)
  (gen-list elem-gen (compose '1+ (gen-num))))

(defun gen-pair (first second)
  `(lambda ()
     (cons (funcall ,first) (funcall ,second))))

(defun gen-types-id ()
  "Generator for types_id values"
  (gen-list (gen-pair (gen-string) (gen-num))))

(defun gen-filtered (elem-gen filter)
  "Filters a generator using a predicate"
  `(lambda ()
     (let ((val (funcall ,elem-gen)))
       (while (not (funcall ,filter val))
         (setq val (funcall ,elem-gen)))
       val)))

(defun gen-any (&rest gens)
  "Generate using any one of the arguments, randomly"
  (unless gens (error "No generators to choose between"))
  `(lambda ()
     (funcall (random-elem ,gens))))

(defun gen-string-without (&rest strs)
  "Generate a string which doesn't contain STR"
  (dolist (str strs)
    (when (equal str "")
      (error "You can't generate string without an empty string!")))
  (gen-filtered  (gen-nonempty-string)
                `(lambda (x)
                   (not (any (mapcar `(lambda (s) (search s ,x)) ',strs))))))

(defun gen-elem (lst)
  "Generate an element of LST"
  (unless lst (error "Cannot generate elements from an empty list"))
  `(lambda ()
     (random-elem ',lst)))

(defun gen-const (&rest args)
  "Generate one of the arguments"
  (unless args (error "No constants to generate"))
  (gen-elem args))

(defun coq-namep (n)
  (not (or (string= n "")
           (string-match "[^a-zA-Z0-9_]" n)
           (string-match "[^a-zA-Z]" (subseq n 0 1)))))

(defun gen-coq-name ()
  (lambda ()
    (let* ((alpha "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
           (alnum (concat alpha "_0123456789"))
           (c     (funcall (gen-char alpha)))
           (cs    (funcall (gen-list (gen-char alnum))))
           (cs2   (if cs (apply 'concat cs) "")))
      (concat c cs2))))

(defun gen-coq-arg (&optional types)
  (let ((gen-type (or types (gen-coq-name))))
    (compose (lambda (names type)
               (list (if type
                         (concat "(" (join-strings names " ") " : " type ")")
                         (concat (join-strings names " ")))))
             (list-of (gen-list (gen-coq-name) (compose '1+ (gen-num)))
                      (gen-any  (gen-const nil) gen-type)))))

(defun gen-coq-theorem-statement (&optional name arg type)
  "Generate a Coq theorem declaration. Optionally, the name will be generated by
   NAME, arguments by ARGS and the theorem's type by TYPE; otherwise they're
   random, syntactically-correct, but logically nonsense."
  (let ((gen-name (or name  (gen-coq-name)))
        (gen-args (gen-list (or arg (gen-coq-arg))))
        (gen-type (or type  (gen-coq-name))))
    (compose (uncurry (lambda (dec name args type)
                        (concat dec " " name " "
                                (join-strings args " ") " "
                                " : " type ".")))
             (list-of (gen-elem (list "Theorem" "Lemma" "Remark" "Fact"
                                      "Corollary" "Proposition"))
                      gen-name
                      gen-args
                      gen-type))))

(defun uncurry (f)
  `(lambda (args) (apply ,f args)))

(defun gen-coq-inhabited-type ()
  "Generate a Coq type which is trivially inhabited; ie. a trivially-provable
   theorem."
  (compose (lambda (nums)
             (concat (join-strings (mapcar 'any-to-string nums) " + ")
                     " = " (any-to-string (apply '+ nums))))
           (gen-list (gen-num) (compose '1+ (gen-num)))))

(defun gen-coq-correct-statement (&optional name)
  "Generate a Coq theorem declaration for a correct theorem. Optionally, the
   name will be generated by NAME, otherwise it's random but syntactically
   correct. Generated theorems are always solvable by 'tauto'."
  (gen-coq-theorem-statement name (gen-const nil) (gen-coq-inhabited-type)))

(defun gen-ltac-step ()
  )

(defun gen-coq-proof (ltac)
  "Generate a Coq proof, including 'Proof' and 'Qed' or 'Defined' markers.
   The proof will probably not be correct!"
  (compose (uncurry (lambda (steps end)
                      (concat "Proof. " (join-strings steps " ") end ".\n")))
           (list-of ltac (gen-elem (list " Qed" " Defined")))))

(defun gen-coq-correct-proof ()
  "Generate a Coq proof whihc will work for trivial theorems, like those from
   gen-coq-inhabited-type"
  (gen-coq-proof (gen-elem (list (list "auto.")
                                 (list "tauto.")
                                 (list "intros." "auto.")
                                 (list "simpl." "reflexivity.")
                                 (list "compute." "auto.")))))

(defun gen-coq-correct-theorem (&optional name)
  (compose (uncurry (lambda (stmt proof)
                      (concat stmt "\n" proof "\n")))
           (list-of (gen-coq-correct-statement name) (gen-coq-correct-proof))))

(defun gen-balanced-parens-aux (pre count gen-str gen-choice)
  "Recursive helper for gen-balanced-parens"
  (if (funcall gen-choice)
      (gen-balances-parens-aux (concat pre (funcall gen-str) "(")
                               (1+ count)
                               gen-str
                               gen-choice)
      (if (= 0 count)
          (concat pre (funcall gen-str))
          (gen-balanced-parens-aux (concat pre (funcall gen-str) ")")
                                   (1- count)
                                   gen-str
                                   gen-choice))))

(defun gen-balanced-parens ()
  "Generate random strings where any parentheses are balanced"
  (lambda ()
    (gen-balanced-parens-aux ""
                             0
                             ;; Don't allow (, ), [ or ] in our strings
                             (gen-string)
                             (gen-filtered (gen-string)
                                           (lambda (x)
                                             (not (or (search "(" x)
                                                      (search ")" x)
                                                      (search "[" x)
                                                      (search "]" x)))))
                             ;; gen-bool gives trees of unlimited expected depth
                             (compose (lambda (x) (= 0 (% x 3)))
                                      (gen-num)))))
