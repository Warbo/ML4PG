(defun list-of (&rest gens)
  `(lambda ()
     (mapcar 'funcall ',gens)))

(defun gen-bool ()
  "Generate t or nil"
  (lambda () (equal (random 2) 0)))

(defun gen-num ()
  "Generate positive random numbers"
  (lambda () (random ml4pg-test-complexity)))

(defun gen-char ()
  "Generate a random ASCII character"
  (lambda () (format "%c" (random 255))))

(defun gen-string (&optional op-len)
  "Generate a random ASCII string, of given (or random) length"
  (let ((len (cond ((functionp op-len)  op-len)
                   ((null      op-len) (gen-num))
                   (t                  (gen-const op-len)))))
    `(lambda ()
       (let ((str ""))
         (dotimes (i (funcall ,len) str)
           (setq str (concat str (funcall (gen-char)))))))))

(defun gen-nonempty-string ()
  "Generate a random ASCII string of at least one char"
  (gen-string (1+ (funcall (gen-num)))))

(defun gen-list (elem-gen &optional op-len)
  "Generate a random list, using the given element-generating function, of the
   given (or random) length"
  (let ((len (cond ((functionp op-len)  op-len)
                   ((null      op-len) (gen-num))
                   (t                  (gen-const op-len)))))
    `(lambda ()
       (let (lst)
         (dotimes (i (funcall ,len) lst)
           (setq lst (cons (funcall ,elem-gen) lst)))))))

(defun gen-pair (first second)
  `(lambda ()
     (cons (funcall ,first) (funcall ,second))))

(defun gen-types-id ()
  "Generator for types_id values"
  (gen-list (gen-pair (gen-string) (gen-num))))

(defun gen-filtered (elem-gen filter)
  "Filters a generator using a predicate"
  `(lambda ()
     (let ((val (funcall ,elem-gen)))
       (while (not (funcall ,filter val))
         (setq val (funcall ,elem-gen)))
       val)))

(defun gen-any (&rest gens)
  "Generate using any one of the arguments, randomly"
  (unless gens (error "No generators to choose between"))
  `(lambda ()
     (funcall (random-elem ,gens))))

(defun gen-string-without (str)
  "Generate a string which doesn't contain STR"
  (gen-filtered (gen-nonempty-string) `(lambda (x) (not (search ,str x)))))

(defun gen-elem (lst)
  "Generate an element of LST"
  (unless lst (error "Cannot generate elements from an empty list"))
  `(lambda ()
     (random-elem ',lst)))

(defun gen-const (&rest args)
  "Generate one of the arguments"
  (unless args (error "No constants to generate"))
  (gen-elem args))

(defun coq-namep (n)
  (not (or (string= n "")
           (string-match "[^a-zA-Z0-9_]" n)
           (string-match "[^a-zA-Z_]" (subseq n 0 1)))))

(defun gen-coq-name ()
  (gen-filtered (gen-nonempty-string) (lambda (x) (coq-namep x))))

(defun gen-coq-arg (&optional types)
  (let ((gen-type (or types (gen-coq-name))))
    (compose (lambda (names type)
               (list (if type
                         (concat "(" (join-strings names " ") " : " type ")")
                         (concat (join-strings names " ")))))
             (list-of (gen-list (gen-coq-name) (compose '1+ (gen-num)))
                      (gen-any  (gen-const nil) gen-type)))))

(defun gen-coq-theorem-statement (&optional name arg type)
  "Generate a Coq theorem declaration. Optionally, the name will be generated by
   NAME, arguments by ARGS and the theorem's type by TYPE; otherwise they're
   random, syntactically-correct, but logically nonsense."
  (let ((gen-name (or name  (gen-coq-name)))
        (gen-args (gen-list (or arg (gen-coq-arg))))
        (gen-type (or type  (gen-coq-name))))
    (compose (uncurry (lambda (dec name args type)
                        (concat dec " " name " "
                                (join-strings args " ") " "
                                " : " type ".")))
             (list-of (gen-elem (list "Theorem" "Lemma" "Remark" "Fact"
                                      "Corollary" "Proposition"))
                      gen-name
                      gen-args
                      gen-type))))

(defun uncurry (f)
  `(lambda (args) (apply ,f args)))

(defun gen-coq-inhabited-type ()
  "Generate a Coq type which is trivially inhabited; ie. a trivially-provable
   theorem."
  (compose (lambda (nums)
             (concat (join-strings (mapcar 'any-to-string nums) " + ")
                     " = " (any-to-string (apply '+ nums))))
           (gen-list (gen-num) (compose '1+ (gen-num)))))

(defun gen-coq-correct-statement (&optional name)
  "Generate a Coq theorem declaration for a correct theorem. Optionally, the
   name will be generated by NAME, otherwise it's random but syntactically
   correct. Generated theorems are always solvable by 'tauto'."
  (gen-coq-theorem-statement name (gen-const nil) (gen-coq-inhabited-type)))

(defun gen-ltac-step ()
  )

(defun gen-coq-proof (&optional ltac)
  "Generate a Coq proof, including 'Proof' and 'Qed' or 'Defined' markers.
   The proof will probably not be correct!"
  (let ((gen-ltac (or ltac (gen-list (gen-ltac-step)))))
    (compose (uncurry (lambda (steps end)
                        (concat "Proof. " (join-strings steps " ") end ".\n")))
             (list-of gen-ltac (gen-elem (list " Qed" " Defined"))))))

(defun gen-coq-correct-proof ()
  "Generate a Coq proof whihc will work for trivial theorems, like those from
   gen-coq-inhabited-type"
  (gen-coq-proof (gen-elem (list (list "auto.")
                                 (list "tauto.")
                                 (list "intros." "auto.")
                                 (list "simpl." "reflexivity.")
                                 (list "compute." "auto.")))))

(defun gen-coq-complete-theorem ()
  (compose (uncurry (lambda (stmt proof)
                      (concat stmt "\n" proof "\n")))
           (list-of (gen-coq-theorem-statement) (gen-coq-proof))))

(defun gen-coq-correct-theorem-aux ()
  (compose (uncurry (lambda (stmt proof)
                      (message "STMT\n%S\nPROOF\n%S\n" stmt proof)
                      (concat stmt "\n" proof "\n")))
           (list-of (gen-coq-correct-statement) (gen-coq-correct-proof))))

(defun gen-coq-correct-theorem ()
  (gen-filtered (gen-coq-correct-theorem-aux)
                (lambda (x) (coqp x))))
