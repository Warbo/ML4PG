(defun export-theorem-comment (result name args)
  (proof-assert-next-command-interactive)
  (export-theorem-aux2 result name args))

(defun export-theorem-deffix (result subcmd args)
  (test-msg (format "A %s" (proof-queue-or-locked-end)))
  (proof-assert-next-command-interactive)
  (test-msg (format "B %s" (proof-queue-or-locked-end)))
  (let ((pos (proof-queue-or-locked-end)))
    (adddefinition subcmd)
    (goto-char pos)
    (proof-goto-point)
    (proof-assert-next-command-interactive))
  (test-msg (format "B2 %s" (proof-queue-or-locked-end)))
  (test-msg "C")
  ;(export-theorem-aux2 result subcmd args)
  (test-msg "D")
  ;(proof-assert-next-command-interactive)
  (test-msg "E"))

(defun export-theorem-defined (name result)
  (proof-assert-next-command-interactive)
  (append-to tactic-level     (compute-tactic-result     name))
  (append-to proof-tree-level (compute-proof-tree-result name))
  (when name
    (split-feature-vector name (flat (reverse result))))
  (ignore-errors (addthm name)))
